"""Bilibili Cookie 处理模块"""
import os
import json
import time
import logging
import tempfile
import urllib.parse
import urllib.request
from typing import Dict, Any, Optional, List

from src.config import get_cookie_cloud_config

_logger = logging.getLogger("yt_dlp_api")


def is_bilibili_url(url: str) -> bool:
    """检查是否为 Bilibili URL"""
    try:
        parsed = urllib.parse.urlparse(url)
        host = (parsed.hostname or "").lower()
        return "bilibili.com" in host or host.endswith(".bilibili.com") or host == "b23.tv"
    except Exception:
        return "bilibili.com" in url or "b23.tv" in url


def _build_cookiecloud_url(server: str, uuid_val: str) -> str:
    """构建 CookieCloud URL"""
    server = server.strip()
    if not server:
        return ""
    if "//" not in server:
        server = "http://" + server
    server = server.rstrip("/")
    return server + "/get/" + uuid_val
    

def _cookies_list_to_header(cookies: List[Dict[str, Any]], domain_keyword: str) -> Optional[str]:
    """将 Cookie 列表转换为 Header 字符串"""
    parts: List[str] = []
    for item in cookies:
        if not isinstance(item, dict):
            continue
        domain = str(item.get("domain", ""))
        if domain_keyword not in domain:
            continue
        name = item.get("name")
        value = item.get("value")
        if not name or value is None:
            continue
        parts.append(f"{name}={value}")
    return "; ".join(parts) if parts else None


def _extract_bilibili_cookie_header(cookie_data: Any) -> Optional[str]:
    """从 CookieCloud 数据中提取 Bilibili Cookie Header"""
    if isinstance(cookie_data, dict):
        for key, val in cookie_data.items():
            if "bilibili.com" in str(key):
                if isinstance(val, str):
                    return val
                if isinstance(val, list):
                    return _cookies_list_to_header(val, "bilibili.com")
        # 兜底：如果是 name->value 结构
        if all(isinstance(v, str) for v in cookie_data.values()):
            return "; ".join([f"{k}={v}" for k, v in cookie_data.items()])
    if isinstance(cookie_data, list):
        return _cookies_list_to_header(cookie_data, "bilibili.com")
    return None


def _extract_bilibili_cookies_list(cookie_data: Any) -> Optional[List[Dict[str, Any]]]:
    """
    从 CookieCloud 数据中提取 Bilibili 的完整 Cookie 列表。
    返回包含 domain, name, value, path, expiry 等字段的 Cookie 列表。
    """
    _logger.debug(f"[Cookie] _extract_bilibili_cookies_list called, cookie_data type: {type(cookie_data).__name__}")
    
    if isinstance(cookie_data, dict):
        _logger.debug(f"[Cookie] cookie_data is dict, keys: {list(cookie_data.keys())}")
        for key, val in cookie_data.items():
            _logger.debug(f"[Cookie] Checking key: {key}, value type: {type(val).__name__}")
            if "bilibili.com" in str(key):
                _logger.debug(f"[Cookie] Found bilibili.com in key: {key}")
                if isinstance(val, list):
                    cookies = [c for c in val if isinstance(c, dict) and "bilibili.com" in str(c.get("domain", ""))]
                    _logger.debug(f"[Cookie] Extracted {len(cookies)} bilibili cookies from list")
                    if cookies:
                        for c in cookies[:5]:  # 只打印前5个
                            _logger.debug(f"[Cookie]   - {c.get('name')}: {c.get('value', '')[:20]}... (domain: {c.get('domain')})")
                    return cookies
    if isinstance(cookie_data, list):
        _logger.debug(f"[Cookie] cookie_data is list with {len(cookie_data)} items")
        cookies = [c for c in cookie_data if isinstance(c, dict) and "bilibili.com" in str(c.get("domain", ""))]
        _logger.debug(f"[Cookie] Extracted {len(cookies)} bilibili cookies from list")
        return cookies
    
    _logger.debug(f"[Cookie] No bilibili cookies found, returning None")
    return None


def _write_cookies_to_netscape_file(cookies: List[Dict[str, Any]], filepath: str) -> None:
    """
    将 Cookie 列表写入 Netscape 格式的 cookie 文件。
    这是 yt-dlp 和 curl 等工具使用的标准格式。
    """
    _logger.debug(f"[Cookie] Writing {len(cookies)} cookies to Netscape file: {filepath}")
    written_count = 0
    important_cookies = ['SESSDATA', 'bili_jct', 'DedeUserID', 'buvid3', 'buvid4']
    found_important = []
    
    with open(filepath, 'w', encoding='utf-8') as f:
        f.write("# Netscape HTTP Cookie File\n")
        f.write("# This file was generated by yt-dlp-api\n\n")
        
        for cookie in cookies:
            domain = cookie.get("domain", "")
            # 处理域名前缀
            if not domain.startswith("."):
                domain = "." + domain
            
            # Netscape 格式: domain, flag, path, secure, expiry, name, value
            flag = "TRUE" if domain.startswith(".") else "FALSE"
            path = cookie.get("path", "/")
            secure = "TRUE" if cookie.get("secure", False) else "FALSE"
            # 使用 expirationDate 或 expiry，如果都没有则设置一个较长的过期时间
            expiry = cookie.get("expirationDate") or cookie.get("expiry")
            if expiry is None:
                expiry = int(time.time()) + 86400 * 365  # 1年后过期
            else:
                expiry = int(expiry)
            name = cookie.get("name", "")
            value = cookie.get("value", "")
            
            if name and value:
                line = f"{domain}\t{flag}\t{path}\t{secure}\t{expiry}\t{name}\t{value}\n"
                f.write(line)
                written_count += 1
                
                # 检查重要的 cookie
                if name in important_cookies:
                    found_important.append(name)
                    _logger.debug(f"[Cookie] Important cookie found: {name}={value[:20]}... (expires: {expiry})")
    
    _logger.debug(f"[Cookie] Written {written_count} cookies to file")
    _logger.debug(f"[Cookie] Important cookies found: {found_important}")
    missing = set(important_cookies) - set(found_important)
    if missing:
        _logger.warning(f"[Cookie] Missing important cookies: {missing}")


def _fetch_bilibili_cookies_list() -> Optional[List[Dict[str, Any]]]:
    """
    从 CookieCloud 获取 Bilibili 的完整 Cookie 列表。
    """
    _logger.debug("[Cookie] _fetch_bilibili_cookies_list called")
    
    cfg = get_cookie_cloud_config()
    server = cfg.get("server")
    password = cfg.get("password")
    uuid_val = cfg.get("uuid")
    
    _logger.debug(f"[Cookie] CookieCloud config - server: {server}, uuid: {uuid_val}, password: {'*' * len(password) if password else 'None'}")

    if not server or not password or not uuid_val:
        _logger.warning("[Cookie] CookieCloud config incomplete, missing server/password/uuid")
        return None

    payload = json.dumps({"password": password}).encode("utf-8")
    headers = {"Content-Type": "application/json"}

    url = _build_cookiecloud_url(server, uuid_val)
    _logger.debug(f"[Cookie] Requesting CookieCloud URL: {url}")

    try:
        req = urllib.request.Request(url, data=payload, headers=headers, method="POST")
        with urllib.request.urlopen(req, timeout=10) as resp:
            status_code = resp.getcode()
            body = resp.read().decode("utf-8")
        
        _logger.debug(f"[Cookie] CookieCloud response status: {status_code}")
        _logger.debug(f"[Cookie] CookieCloud response length: {len(body)} bytes")
        
        data = json.loads(body)
        _logger.debug(f"[Cookie] CookieCloud response keys: {list(data.keys())}")

        cookie_data = data.get("cookie_data")
        if cookie_data is None and isinstance(data.get("data"), dict):
            _logger.debug("[Cookie] cookie_data not in root, checking data.cookie_data")
            cookie_data = data["data"].get("cookie_data")
        
        if cookie_data is None:
            _logger.warning("[Cookie] No cookie_data found in CookieCloud response")
            _logger.debug(f"[Cookie] Full response: {body[:500]}...")
            return None

        cookies_list = _extract_bilibili_cookies_list(cookie_data)
        if cookies_list:
            _logger.info(f"[Cookie] Fetched {len(cookies_list)} Bilibili cookies from CookieCloud")
            return cookies_list
        else:
            _logger.warning("[Cookie] No Bilibili cookies found in CookieCloud data")
            if isinstance(cookie_data, dict):
                _logger.debug(f"[Cookie] Available domains in cookie_data: {list(cookie_data.keys())}")
            return None
    except Exception as e:
        _logger.error(f"[Cookie] CookieCloud request failed for {url}: {e}")
        import traceback
        _logger.debug(f"[Cookie] Traceback: {traceback.format_exc()}")

    return None


def _fetch_bilibili_cookie_header() -> Optional[str]:
    """从 CookieCloud 获取 Bilibili Cookie Header"""
    cfg = get_cookie_cloud_config()
    server = cfg.get("server")
    password = cfg.get("password")
    uuid_val = cfg.get("uuid")

    if not server or not password or not uuid_val:
        return None

    payload = json.dumps({"password": password}).encode("utf-8")
    headers = {"Content-Type": "application/json"}

    url = _build_cookiecloud_url(server, uuid_val)

    try:
        req = urllib.request.Request(url, data=payload, headers=headers, method="POST")
        with urllib.request.urlopen(req, timeout=10) as resp:
            body = resp.read().decode("utf-8")
        data = json.loads(body)

        cookie_data = data.get("cookie_data")
        if cookie_data is None and isinstance(data.get("data"), dict):
            cookie_data = data["data"].get("cookie_data")

        cookie_header = _extract_bilibili_cookie_header(cookie_data)
        if cookie_header:
            return cookie_header
    except Exception as e:
        _logger.warning(f"CookieCloud request failed for {url}: {e}")

    return None


def apply_cookie_options(opts: Dict[str, Any], url: str, log_prefix: str = "[Cookie]") -> tuple[Dict[str, Any], Optional[str]]:
    """
    根据 URL 判断是否需要添加 cookie 配置到 yt-dlp 选项中。
    
    Args:
        opts (Dict[str, Any]): yt-dlp 的选项字典
        url (str): 视频 URL
        log_prefix (str): 日志前缀，用于区分调用来源
        
    Returns:
        tuple[Dict[str, Any], Optional[str]]: 返回修改后的 opts 和临时 cookie 文件路径（如果有）
            - opts: 修改后的 yt-dlp 选项字典
            - cookie_file_path: 临时 cookie 文件路径，调用方需要在使用完后清理
    """
    cookie_file_path = None
    is_bili = is_bilibili_url(url)
    
    _logger.debug(f"{log_prefix} URL: {url}")
    _logger.debug(f"{log_prefix} Is Bilibili: {is_bili}")
    
    if is_bili:
        _logger.info(f"{log_prefix} Bilibili URL detected, attempting to fetch cookies from CookieCloud")
        cookies_list = _fetch_bilibili_cookies_list()
        if cookies_list:
            # 创建临时 cookie 文件
            cookie_file = tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False, encoding='utf-8')
            _write_cookies_to_netscape_file(cookies_list, cookie_file.name)
            cookie_file.close()
            cookie_file_path = cookie_file.name
            _logger.info(f"{log_prefix} Cookie file created at: {cookie_file_path}")
            
            # 设置 cookiefile 选项
            opts['cookiefile'] = cookie_file_path
            _logger.debug(f"{log_prefix} Using cookiefile: {cookie_file_path}")
            
            # 打印 cookie 文件内容用于调试
            try:
                with open(cookie_file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    _logger.debug(f"{log_prefix} Cookie file content:\n{content}")
            except Exception as e:
                _logger.debug(f"{log_prefix} Failed to read cookie file: {e}")
        else:
            _logger.warning(f"{log_prefix} No cookies fetched from CookieCloud!")
        
        # Bilibili 需要正确的 Referer 和 User-Agent
        opts['http_headers'] = {
            'Referer': 'https://www.bilibili.com/',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        }
        _logger.debug(f"{log_prefix} Added Bilibili headers: Referer and User-Agent")
    
    return opts, cookie_file_path


def cleanup_cookie_file(cookie_file_path: Optional[str], log_prefix: str = "[Cookie]") -> None:
    """
    清理临时 cookie 文件。
    
    Args:
        cookie_file_path (Optional[str]): cookie 文件路径
        log_prefix (str): 日志前缀
    """
    if cookie_file_path and os.path.exists(cookie_file_path):
        try:
            os.unlink(cookie_file_path)
            _logger.debug(f"{log_prefix} Cleaned up cookie file: {cookie_file_path}")
        except Exception as e:
            _logger.warning(f"{log_prefix} Failed to clean up cookie file: {e}")
